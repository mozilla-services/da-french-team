Notifications in Kinto (Preamble)
#################################

:lang: en
:url: notifications-kinto-preamble
:slug: notifications-kinto-preamble
:date: 2015-08-13
:summary: Notifications are coming to Kinto! Here's the introduction.

At a recent work week in the lovely French town of `Dournenez <https://www.qwant.com/?q=dournenez&t=images>`_ we laid the groundwork for an upcoming feature in `Kinto <https://kinto.readthedocs.org>`_: *Notifications*!

What?
=====

Before we go into the gritty details, let's take a moment to come to an understanding about some core terminology, shall we? Notifications are messages which trigger actions, the combination of which is called an event. Actions can in turn generate further notifications, resulting in further events, and so forth until the end of time (or thread).

Notifications can come from *somewhere else*, such as an external service, or can be generated internally. Actions can be native functions of Kinto, local executables, features from plugins, and so forth. In general, actions will produce some sort of interesting output. Events can therefore be thought of as a cycle: a message is received, an action takes place, and a message is generated.

This is a pretty gross simplification - and we'll explore some more terminology later - but for now let's move along.

Why?
====

The simple answer is that we have an itch to scratch at Mozilla. There is a platform called `Balrog <https://wiki.mozilla.org/Balrog>`_ which is part of the update system used by Firefox and other Mozilla products. As part of an initiative to extend and improve the update process (the "`Go Faster <https://wiki.mozilla.org/Firefox/Go_Faster>`_" initiative), we needed to store and transmit small, discrete blocks of information both between internal systems, as well as out to all of our users in the real world. Kinto has almost all the functionality we need except for one thing: notifications.

No problem. We can do that.

But wait, there's more!
=======================

Sure, Kinto is a Mozilla project - but it's meant for general use, which means that anything we design needs to be reasonably generic. With this in mind we committed to designing something that can be used in a variety of contexts; after all, we're an organisation built for and on the web, and as such, we're dedicated to using web-centric solutions.

Thinking then about what sort of parameters a reasonably generic solution might entail lead us to a few basic guidelines for designing the notifications mechanism:

* We should strive to be as *agnostic* as possible, meaning that locking into a particular service, back-end, or even programming language, should be avoided where possible.
* Since we're web-centric, we should capitalise on HTTP wherever possible as well.
* The notifications mechanism must be able to scale with a minimum of hardship; this applies to any eventual queues, workers, and so forth.
* Finally, it must be robust - we can't be losing messages now, can we?

How?
====

There are about as many ways to go about solving the problem as there are grains of sand on a beach (warning: previous statement may not be scientifically valid). The best way to determine the winning approach is simple: through single combat, `Thunderdome-style <https://duckduckgo.com/?q=beyond+thunderdome&ia=about>`_. Unfortunately our manager put the kibosh on that plan for liability reasons, so instead we did the next best thing: we drew on a whiteboard.

In the interest of absolutely transparency, here are some of the models that we worked through and our general observations on each.

The Simple
----------

One approach is to be as `hands-off <https://i.imgur.com/xZQitlj.gif>`_ as possible. The premise here is straightforward enough: Kinto drops notifications into a queue (like Redis or RabbitMQ). That's basically it.

Pros:

* This model implies a highly limited scope insofar as Kinto is directly concerned; we would basically treat Kinto like a lightweight transport mechanism, and the queue as a fire-and-forget target.
* The amount of additional code would be relatively small - in essence, only just enough to speak to a queue service and nothing more.
* We could ship with support for a handful of external queuing services.

Cons:

* We'd have to code and maintain support for a handful of external queuing services.
* It's ultimately up to the final consumer (receiver, destination, whatever) of the message to deal with the queue. In other words, if the queue is RabbitMQ, then the consumer needs to able to speak RabbitMQ too.
* Kinto has no control, understanding, or insight into what happens once the message is handed off to the queuing service.

The simplicity of this model, while attractive, has some fatal flaws. Chiefly, it runs contrary to our guideline of tech agnosticism as it would impose a particular external service dependency on the *consumer*. Furthermore, this model flirts with danger in terms of robustness - the fire-and-forget model isn't exactly optimised for reliability.

The Integrated
--------------

We then considered what might happen if we were to swing the pendulum directly to the opposite of the spectrum from the previous solution. In this model, we would tightly couple the queuing service directly within Kinto and provide an API that the consumer could subscribe to.

Pros:

* Kinto could be shipped as a "turn-key" solution with a fully functioning stack baked right in; while there would be a queuing service involved (`Celery <http://www.celeryproject.org/>`_, for example), it would be completely abstracted by Kinto.
* Since the queuing mechanism is integral, Kinto would have full visibility and control over processing and delivery.
* Apart from the queuing service there would be no additional services or software to deploy.

Cons:

* This would involve a fairly serious increase in the scope, complexity, and size of the Kinto code base.
* The tight coupling means that Kinto, in its entirety, would need to be re-deployed if changes were necessary in the queuing service.
* Similarly, scaling the queue would imply scaling Kinto itself

This model has certain interesting advantages; however, the relative volume of additional code that would need to be developed is reason enough to give us pause (`scope creep <https://en.wikipedia.org/wiki/Scope_creep>`_ is a real problem). Like the previous model, this also runs afoul of our tech agnosticism guideline since we would be locking Kinto to a given queuing service directly. Finally, we have (admittedly theoretical) concerns about how this model would scale - it feels like a waste to increase two resources when only one needs to grow, for example.

The Broker
----------

The final approach is a bit of a mix of the previous two. In this model, we implement a formal "broker" that is part of the Kinto *eco-system*, but external to Kinto itself. The roker could be anything from a few lines of Python sitting on a `pipe <https://en.wikipedia.org/wiki/Named_pipe>`_ to a proper micro-service stack. This decouples the queuing mechanism from Kinto while preserving a strong *promise* of interoperability and control.

Pros:

* Provides a clean and easily understandable separation of responsibilities.
* Frees both Kinto and the consumer from any particular service dependency.
* Permits the broker to scale independently from Kinto.
* Requires only a moderate amount of new code.
* Effectively allows for a highly flexible solution where just about anything imaginable could be plugged in.

Cons:

* The broker must speak HTTP and respond properly to a specification of our choosing.
* Functionally requires deploying and maintaining two services (the difficulty of which varies according the complexity of the broker).

We like this model because it satisfies most of our guidelines (and violates none). To be fair, the requirement for "robustness" is a little hand-wavey in this case. We are effectively handing the responsibility to another component; however, since interoperability is a promise, we can maintain an acceptable degree of confidence in the process.

A final point worth mentioning here is that the broker could, in principle, be the *consumer itself*, which fits into some of the potential use-cases at Mozilla quite nicely.

Roadmap
=======

As you may have guessed, we've decided to go with the third option (The Broker). From here we have a plan to get from idea to reality, starting with a proof of concept, then through to a `minimum viable product <https://en.wikipedia.org/wiki/Minimum_viable_product>`_, and then iterating through improvements until we get to something that's useful to a wider audience.

Concretely speaking the proof of concept will require:

* Defining the *types* of events; functionally, this means specifying the behaviour and scope of ``pre-`` and ``post-`` patterns, as well as the structure of the payload.
* Construct a framework for synchronous internal Python events using `Pyramid events <http://docs.pylonsproject.org/projects/pyramid//en/latest/narr/events.html>`_ (something we have `experience with already <https://github.com/spiral-project/daybed/blob/master/daybed/events.py>`_).
* Implement a "listener" in Kinto for those events in order to execute an action.

From there, we'll move on to the minimum viable product:

* Build a minimalist HTTP service that receives a notification via an HTTP ``POST``, performs an action, and communicates the result to Balrog directly.

Once the model is validated we'll begin the iterative improvement process. This will likely take the form of a "standard broker" which we create and maintain as part of the formal ecosystem. We also like the idea of subscribers registering themselves to the broker using an endpoint (such as webhooks), but that's a discussion for future time.
